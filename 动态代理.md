Java-JDK动态代理（AOP）使用及实现原理分析
##第一章:代理的介绍
介绍:我们需要掌握的程度
动态代理(理解) 基于反射机制
掌握的程度:
1. 什么是动态代理?
    使用jdk的反射机制，创建对象的能力，创建的是代理类的对象。而不用你创建类文件，不用写java文件。
    动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。
    jdk动态代理，必须要有接口，目标类必须实现接口
2. 动态代理能够做什么?
    可以在不改变原来目标方法功能的前提下，可以在代理中加强自己的功能代码。
后面我们在用Spirng和Mybatis的时候,要理解怎么使用的.
------------------------------------------------
一、什么是代理?
代理,在我们日常生活之中就有体现,代购,中介,换ip,商家等等.
比如有一家美国的大学,可以对全世界招生.留学中介(代理 )
留学中介(代理):帮助这家美国的学校招生,中介是学校的代理中介是代替学校完成招生功能
#代理特点
1. 中介和代理他们要做的事情是一致的:招生
2. 中介是学校代理,学校是目标
3. 家长----->中介(学校介绍,办理入学手续)---->美国学校
4. 中介是代理,收取费用
二、为什么要进行代理（找中介）?
1. 中介是专业的,方便.
2. 家长现在不能自己去找学校。家长没有能力访问学校.或者美国学校不接收个人来访
买东西都是商家卖, 商家是某个商品的代理, 你个人买东西,肯定不会让你接触到厂家的.
* 在开发中存在a类需要调用c类的方法，完成某一个功能，但是c禁止a调用。这时，可以在a和c之间创建一个b类代理，a类访问b类，b类访问c类。例如：登录的时候需要进行短信验证，这个时候代理就是中国移动的子公司来完成短信的发送功能.
* 代理模式就是为其他对象提供一种代理来控制这个对象的访问，在某些情况下一个对象不适合或不能直接引用另一个对象，而代理对象可以在客户类和目标对象直接起到中介的作用
三、使用代理模式的作用
* 功能增强：其中目标对象实现真正的功能，但是代理对象可以对目标对象的功能做进一步的扩充
* 控制访问：代理类不让你访问目标
四、实现代理的方式
静态代理与动态代理
##第二章:静态代理
![](/静态代理.png)
1. 代理类是自己手工实现的，自己创建一个java类，表示代理类。
2. 同时你所需要代理的目标类是确定的。
实现简单，容易理解
#模拟一个用户购买u盘的行为。
用户是客户端类
商家：代理，代理某个品牌的u盘。
厂家：目标类。
三者的关系：用户（客户端）-—-商家（代理）-—-厂家（目标）
商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘。
实现步骤:
1.创建一个接口,定义卖u盘的方法,表示你的厂家和商家做的事情
2.创建厂家类,实现1步骤的接口
3.创建商家,就是代理,也需要实现1步骤中的接口
4.创建客户端类,调用商家的方法买一个u盘
所以我们再次总结代理类完成的功能:
1.目标类中方法的调用 2.功能增强
#静态代理的优缺点
优点:实现简单,容易简单
缺点:（项目中目标类的代理类很多的时候）
1.当目标类增加了,代理类可能也需要成倍的增加；
2.当你的接口中功能增加或者修改,会影响众多的实现类,厂家类,代理都需要修改,影响比较大.
##第三章:动态代理
![](/动态代理.png)
在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点。
动态代理中的目标类即使很多，1.代理类的数量也可以很少。2.当你修改了接口中的方法时，不会影响代理类。
* 动态代理:在程序执行过程中,使用jdk的反射机制,创建代理类对象,并动态的指定要代理目标类。不用创建类文件，不用写java文件。
* 动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。
换句话说:动态代理是一种创建java对象的能力,让你不用创建 TaoBao类就能创建代理类对象,除去了中间商。
在java中,要想创建对象
1.创建类文件.java 文件编译为class
2.使用构造方法,创建类的对象
动态代理的实现：
1. jdk动态代理(理解):使用java反射包中的类和接口实现动态代理的功能,反射包java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy
2. cglib(code generation library)动态代理(了解): cglib是第三方的工具库,创建代理对象
1）cglib的原理是继承,cglib通过继承目标类,创建它的子类,在子类中
重写父类中同名的方法,实现功能的修改。
2）因为cglib是继承,重写方法,所以要求目标类不能是final的,方法也不能是final的。cglib的要求目标类比较宽松,只要能继承就可以了。cglib在很多的框架中使用,比如mybatis,spring框架中都有使用。
##复习反射机制：
1.反射，Method类,表示方法。类中的方法。通过Method可以执行某个方法。
2.jdk动态代理的实现
    反射包java.lang.reflect,里面有三个类:InvocationHandler, Method, Proxy。
1）InvocationHandler接口（调用处理器）：一个方法invoke（）
    invoke（）：表示代理对象要执行的功能代码，代理类要完成的功能卸载invoke（）方法中。
    代理类完成的功能：1.调用目标方法。2.功能增强。
* 方法的原型：
    参数：Object proxy:jdk创建的代理对象，无需赋值
        Method method:目标类中的方法，jdk提供method对象的方法
        Object[] args:目标类中的方法参数，jdk提供的  
` public Object invoke(Object proxy, Method method, Object[] args)`
InvocationHandler接口：表示你的代理要干什么
怎么用？1.创建类实现接口InvocationHandler。2.重写invoke（）方法，把原来静态代理类要完成的功能，写在这里
2）Method类:表示方法的,确切的说就是目标类中的方法。
作用:通过 Method可以执行某个目标类的方法, Method. invoke();
method. invoke(目标对象,方法的参数)
`object ret= method. invoke(service22,"李四")`
说明:method.invoke()就是为了用来执行目标方法的,等同于静态代理中的
` float price = factory.sell(amount);`
3）proxy类：核心的对象，创建代理对象。之前创建对象都是new类的构造方法（）
现在我们是使用proxy类的方法，代替new的使用。
方法：静态方法 newProxyInstance(）
作用是：创建代理对象，等同于静态代理中的TaoBao taoBao=new TaoBao()
我们来观察方法原型：
`public static Object newProxyInstance( ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`
参数：
1.ClassLoader loader 类加载器,负责向内存中加载对象的。使用反射机制获取对象的classLoader。
如何获取类a的类加载器： a.getCalss().getClassLoader(),目标对象的类加载器
这里我们细分:每一个类都继承Object类,在Object中有一个getClass方法,表示 类对象的运行时类的Class对象。 而Class类里面有一个public ClassLoader getClassLoader()方法
2.Class<?>[] interfaces: 接口,目标对象实现的接口,也是反射获取的
3.InvocationHandler h : 我们自己写的,代理类要完成的功能
返回值：就是代理对象
##第四章 实现动态代理的步骤
1. 创建接口,定义目标类要完成的功能
2. 创建目标类实现接口
3. 创建InvocationHandler接口的实现类,在invoke方法中完成代理类的功能
    调用目标方法，增强功能
4. 使用Proxy类的静态方法,创建代理对象,并把返回值转换成接口类型
##第五章 JDK动态代理执行流程
动态代理流程：
![](动态代理流程.png)
![](/动态代理流程图.png)





